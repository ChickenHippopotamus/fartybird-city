<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>FartyBird: City Edition</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #333;
    font-family: 'Press Start 2P', cursive;
    touch-action: none; /* Prevent zoom/scroll on mobile */
  }

  #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    background-color: #70c5ce;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
  }

  canvas {
    display: block;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    max-width: 100%;
    max-height: 100%;
    /* Ensure crisp pixel art rendering */
    image-rendering: pixelated; 
  }

  #ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    text-shadow: 2px 2px 0 #000;
  }

  .hidden {
    display: none !important;
  }

  #score-display {
    position: absolute;
    top: 10%;
    font-size: 4rem;
    color: white;
    z-index: 10;
  }

  #start-screen, #game-over-screen {
    background: rgba(0, 0, 0, 0.85);
    padding: 20px;
    border-radius: 10px;
    color: white;
    pointer-events: auto;
    border: 2px solid #555;
    max-width: 90%;
    max-height: 90vh;
    overflow-y: auto;
  }

  h1 {
    font-size: 3rem;
    margin: 0 0 20px 0;
    color: #f4b41b;
    text-shadow: 3px 3px 0 #000;
    line-height: 1.2;
  }

  p {
    font-size: 0.8rem;
    line-height: 1.5;
    margin-bottom: 20px;
    color: #ddd;
  }

  .btn {
    background: #e06020;
    border: 2px solid white;
    color: white;
    padding: 15px 30px;
    font-family: 'Press Start 2P', cursive;
    font-size: 1.2rem;
    cursor: pointer;
    text-transform: uppercase;
    box-shadow: 0 4px 0 #8a3000;
    transition: transform 0.1s;
    margin-top: 10px;
  }

  .btn:active {
    transform: translateY(4px);
    box-shadow: 0 0 0 #8a3000;
  }

  #high-score {
    font-size: 1rem;
    color: #ffcc00;
    margin-top: 10px;
    margin-bottom: 15px;
  }

  /* --- Character Selector --- */
  .character-selector {
    margin: 15px 0;
  }

  .character-selector label {
    font-size: 0.7rem;
    color: #ffcc00;
    display: block;
    margin-bottom: 8px;
  }

  .character-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    max-width: 280px;
    margin: 0 auto;
  }

  .char-btn {
    width: 60px;
    height: 60px;
    border: 3px solid #555;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
    cursor: pointer;
    padding: 4px;
    transition: all 0.2s;
  }

  .char-btn:hover {
    border-color: #ffcc00;
    transform: scale(1.1);
  }

  .char-btn.selected {
    border-color: #f4b41b;
    box-shadow: 0 0 10px #f4b41b;
    background: rgba(244, 180, 27, 0.2);
  }

  .char-preview {
    width: 100%;
    height: 100%;
  }

  /* --- Difficulty Selector --- */
  .difficulty-selector {
    margin: 15px 0;
  }

  .difficulty-selector label {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.7rem;
    color: #ffcc00;
    display: block;
    margin-bottom: 8px;
  }

  .difficulty-btns {
    display: flex;
    gap: 8px;
    justify-content: center;
  }

  .diff-btn {
    padding: 8px 12px;
    border: 2px solid #555;
    border-radius: 6px;
    background: rgba(0,0,0,0.5);
    color: white;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.6rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .diff-btn:hover {
    border-color: #ffcc00;
    transform: scale(1.05);
  }

  .diff-btn.selected {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.3);
    box-shadow: 0 0 10px #4CAF50;
  }

  /* Specific colors for active states if needed, though .selected handles logic */
  .diff-btn.easy.selected { color: #4CAF50; border-color: #4CAF50; }
  .diff-btn.normal.selected { color: #ffcc00; border-color: #ffcc00; }
  .diff-btn.hard.selected { color: #ff6b6b; border-color: #ff6b6b; }

  /* --- Leaderboard Styles --- */
  .leaderboard-container {
    margin-top: 15px;
    max-height: 150px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #ffcc00 #333;
    border-top: 1px solid #555;
    padding-top: 10px;
  }

  .leaderboard-table {
    width: 100%;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.6rem;
    border-collapse: collapse;
  }

  .leaderboard-table th,
  .leaderboard-table td {
    padding: 6px 8px;
    text-align: left;
  }

  .leaderboard-table th {
    color: #ffcc00;
    border-bottom: 1px solid #555;
  }

  .leaderboard-table tr:nth-child(even) {
    background: rgba(255,255,255,0.05);
  }

  .leaderboard-table .gold { color: #ffd700; }
  .leaderboard-table .silver { color: #c0c0c0; }
  .leaderboard-table .bronze { color: #cd7f32; }

  #name-input-container {
    margin-top: 15px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
  }

  #player-name {
    padding: 10px;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8rem;
    background: rgba(0,0,0,0.5);
    border: 2px solid #555;
    color: white;
    text-transform: uppercase;
    width: 100px;
    text-align: center;
  }

  #submit-score-btn {
    padding: 10px 15px;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.7rem;
    background: #4CAF50;
    border: none;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
  }

  #submit-score-btn:hover {
    background: #45a049;
  }

</style>
</head>
<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>
  <div id="ui-layer">
    <div id="score-display" class="hidden">0</div>
    
    <div id="start-screen">
      <h1>FARTY<br>BIRD</h1>
      <p>Tap, Click, or Space<br>to Fart & Fly!</p>
      
      <div class="character-selector">
        <label>CHOOSE YOUR BIRD:</label>
        <div class="character-grid">
          <button class="char-btn selected" data-char="0" title="Cool Duck"><canvas class="char-preview" id="char-0"></canvas></button>
          <button class="char-btn" data-char="1" title="Beanie Bird"><canvas class="char-preview" id="char-1"></canvas></button>
          <button class="char-btn" data-char="2" title="Crying Bird"><canvas class="char-preview" id="char-2"></canvas></button>
          <button class="char-btn" data-char="3" title="Bandana Duck"><canvas class="char-preview" id="char-3"></canvas></button>
          <button class="char-btn" data-char="4" title="Fancy Bird"><canvas class="char-preview" id="char-4"></canvas></button>
          <button class="char-btn" data-char="5" title="Derpy Bird"><canvas class="char-preview" id="char-5"></canvas></button>
          <button class="char-btn" data-char="6" title="Queen Bird"><canvas class="char-preview" id="char-6"></canvas></button>
          <button class="char-btn" data-char="7" title="Chonky Bird"><canvas class="char-preview" id="char-7"></canvas></button>
        </div>
      </div>
      
      <div class="difficulty-selector">
        <label>DIFFICULTY:</label>
        <div class="difficulty-btns">
          <button class="diff-btn easy selected" data-diff="easy">EASY</button>
          <button class="diff-btn normal" data-diff="normal">NORMAL</button>
          <button class="diff-btn hard" data-diff="hard">HARD</button>
        </div>
      </div>
      
      <button class="btn" id="start-btn">PLAY</button>
    </div>

    <div id="game-over-screen" class="hidden">
      <h1>GAME OVER</h1>
      <div id="final-score">Score: 0</div>
      <div id="high-score">Best: 0</div>
      
      <button class="btn" id="restart-btn">RETRY</button>

      <div id="name-input-container">
        <input type="text" id="player-name" maxlength="3" placeholder="AAA">
        <button id="submit-score-btn">SAVE</button>
      </div>

      <div class="leaderboard-container">
        <table class="leaderboard-table">
          <thead>
            <tr><th>#</th><th>NAME</th><th>SCORE</th></tr>
          </thead>
          <tbody id="leaderboard-body">
            </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
/**
 * FARTYBIRD GAME ENGINE
 * City Night Edition ðŸ‘‘ðŸ’¨
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// UI Elements
const scoreEl = document.getElementById('score-display');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');
const highScoreEl = document.getElementById('high-score');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');

// Game Constants
let frames = 0;
const DEGREE = Math.PI / 180;
let GAME_SPEED = 3;

// Game State
const state = {
  current: 0,
  getReady: 0,
  game: 1,
  over: 2
};

let score = {
  best: parseInt(localStorage.getItem('fartybird_best'), 10) || 0,
  value: 0
};

// Character & Difficulty Variables
let selectedCharacter = 0;
let selectedDifficulty = 'easy';
let gameOverCalled = false;
let spawnRate = 120; 

// Difficulty Config
const difficultySettings = {
  easy: {
    gap: 200,       
    pipeSpeed: 1.5,     
    spawnRate: 120,     
    gravity: 0.2,       
    jump: 4.2           
  },
  normal: {
    gap: 170,  
    pipeSpeed: 2,
    spawnRate: 100,
    gravity: 0.25, 
    jump: 4.6
  },
  hard: {
    gap: 140,           
    pipeSpeed: 2.8,     
    spawnRate: 80,      
    gravity: 0.3,       
    jump: 5.0           
  }
};

// ============================================
// AUDIO SYSTEM
// ============================================
let audioCtx = null;
let bgMusicStarted = false;
let bgGainNode = null;

async function initAudioContext() {
  try {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      await audioCtx.resume();
    }
    return audioCtx;
  } catch (error) {
    console.warn('Audio init failed:', error);
    return null;
  }
}

// Background Music Variables
const BPM = 90;
const STEP_TIME = (60 / BPM) / 4; 
let currentStep = 0;
let beatInterval = null;

// Beat Patterns
const kickPattern =  [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,1,0];
const snarePattern = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0];
const hihatPattern = [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0];
const bassPattern =  [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0];
const bassNotes =    [55,0,0,55, 0,0,62, 0, 55,0,0,55, 0,0,49,0];

function playKick(time) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(bgGainNode);
  osc.frequency.setValueAtTime(150, time);
  osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
  gain.gain.setValueAtTime(0.5, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
  osc.start(time);
  osc.stop(time + 0.15);
}

function playSnare(time) {
  const bufferSize = audioCtx.sampleRate * 0.1;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'highpass';
  filter.frequency.value = 1000;
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.3, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
  noise.connect(filter);
  filter.connect(gain);
  gain.connect(bgGainNode);
  noise.start(time);
  noise.stop(time + 0.1);
  // Tone
  const osc = audioCtx.createOscillator();
  const oscGain = audioCtx.createGain();
  osc.connect(oscGain);
  oscGain.connect(bgGainNode);
  osc.frequency.value = 200;
  oscGain.gain.setValueAtTime(0.2, time);
  oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
  osc.start(time);
  osc.stop(time + 0.05);
}

function playHihat(time) {
  const bufferSize = audioCtx.sampleRate * 0.05;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'highpass';
  filter.frequency.value = 7000;
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.08, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + 0.03);
  noise.connect(filter);
  filter.connect(gain);
  gain.connect(bgGainNode);
  noise.start(time);
  noise.stop(time + 0.05);
}

function playBass(time, freq) {
  if (!freq) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'sawtooth';
  osc.frequency.value = freq;
  filter.type = 'lowpass';
  filter.frequency.value = 300;
  filter.Q.value = 5;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(bgGainNode);
  gain.gain.setValueAtTime(0.25, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
  osc.start(time);
  osc.stop(time + 0.15);
}

function scheduleBeat() {
  const time = audioCtx.currentTime;
  if (kickPattern[currentStep]) playKick(time);
  if (snarePattern[currentStep]) playSnare(time);
  if (hihatPattern[currentStep]) playHihat(time);
  if (bassPattern[currentStep]) playBass(time, bassNotes[currentStep]);
  currentStep = (currentStep + 1) % 16;
}

async function startBackgroundMusic() {
  if (bgMusicStarted) return;
  try {
    await initAudioContext();
    if (!audioCtx) return;
    bgMusicStarted = true;
    bgGainNode = audioCtx.createGain();
    bgGainNode.gain.value = 0.4;
    bgGainNode.connect(audioCtx.destination);
    beatInterval = setInterval(scheduleBeat, STEP_TIME * 1000);
  } catch (error) {
    console.warn('BG music failed:', error);
  }
}

async function playFart() {
  try {
    await initAudioContext();
    if (!audioCtx) return;
    
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    const rattleOsc = audioCtx.createOscillator();
    const rattleGain = audioCtx.createGain();

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    rattleOsc.connect(rattleGain);
    rattleGain.connect(osc.frequency);

    let duration = 0.5, startFreq = 150, endFreq = 50, filterQ = 1, rattleSpeed = 0, rattleAmount = 0;
    const r = () => Math.random() * 0.2 + 0.9;
    const fartTypes = ['tight', 'dry', 'rolling', 'wet', 'sticky', 'long'];
    const type = fartTypes[Math.floor(Math.random() * fartTypes.length)];

    switch (type) {
      case 'tight': osc.type = 'sawtooth'; duration = 0.1 * r(); startFreq = 400 * r(); endFreq = 300 * r(); filterQ = 15; break;
      case 'dry': osc.type = 'sawtooth'; duration = 0.4 * r(); startFreq = 200 * r(); endFreq = 40; filterQ = 2; break;
      case 'rolling': osc.type = 'sawtooth'; duration = 0.8 * r(); startFreq = 80; endFreq = 40; rattleSpeed = 25; rattleAmount = 30; filterQ = 5; break;
      case 'wet': osc.type = 'sawtooth'; duration = 0.4 * r(); startFreq = 180; endFreq = 100; filterQ = 12; rattleSpeed = 10; rattleAmount = 10; break;
      case 'sticky': osc.type = 'square'; duration = 0.6; startFreq = 100; endFreq = 120; filterQ = 20; break;
      case 'long': osc.type = 'sawtooth'; duration = 2.0; startFreq = 130; endFreq = 30; rattleSpeed = 6; rattleAmount = 15; filterQ = 4; break;
    }

    osc.frequency.setValueAtTime(startFreq, t);
    osc.frequency.exponentialRampToValueAtTime(Math.max(1, endFreq), t + duration);

    if (rattleSpeed > 0) {
      rattleOsc.type = 'sawtooth';
      rattleOsc.frequency.value = rattleSpeed;
      rattleGain.gain.setValueAtTime(rattleAmount, t);
      rattleGain.gain.linearRampToValueAtTime(0, t + duration);
      rattleOsc.start(t);
      rattleOsc.stop(t + duration + 0.1);
    }

    filter.type = 'lowpass';
    filter.Q.value = filterQ;
    filter.frequency.setValueAtTime(800, t);
    filter.frequency.exponentialRampToValueAtTime(50, t + duration);

    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.5, t + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.01, t + duration);

    osc.start(t);
    osc.stop(t + duration + 0.1);

    setTimeout(() => {
      osc.disconnect(); gain.disconnect(); filter.disconnect(); rattleOsc.disconnect(); rattleGain.disconnect();
    }, duration * 1000 + 200);

  } catch (error) { console.warn('Fart failed:', error); }
}

async function playSelectChime() {
  try {
    await initAudioContext();
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    [523, 659, 784].forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, t + i * 0.1);
      gain.gain.linearRampToValueAtTime(0.2, t + i * 0.1 + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.1 + 0.3);
      osc.start(t + i * 0.1);
      osc.stop(t + i * 0.1 + 0.3);
    });
  } catch (e) { }
}

async function playDifficultySelect() {
  try {
    await initAudioContext();
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(440, t);
    osc.frequency.setValueAtTime(550, t + 0.1);
    gain.gain.setValueAtTime(0.15, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    osc.start(t);
    osc.stop(t + 0.2);
  } catch (e) { }
}

async function playDeathSound() {
  try {
    await initAudioContext();
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const deathType = Math.floor(Math.random() * 3);
    if (deathType === 0) { // Spiral
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(100, t + 0.5);
      gain.gain.setValueAtTime(0.3, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
      osc.start(t);
      osc.stop(t + 0.5);
    } else if (deathType === 1) { // Sad trombone
      [300, 280, 260, 240].forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'triangle';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.2, t + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.15 + 0.14);
        osc.start(t + i * 0.15);
        osc.stop(t + i * 0.15 + 0.15);
      });
    } else { // Crash
      const bufferSize = audioCtx.sampleRate * 0.3;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 500;
      const gain = audioCtx.createGain();
      gain.gain.value = 0.4;
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      noise.start(t);
    }
  } catch (e) { }
}

// ============================================
// VISUAL ASSETS
// ============================================

// Fart Cloud Particles
const fartClouds = [];
const specklePalettes = [
  [{ r: 101, g: 67, b: 33 }, { r: 189, g: 183, b: 107 }],
  [{ r: 85, g: 107, b: 47 }, { r: 154, g: 205, b: 50 }],
  [{ r: 128, g: 0, b: 128 }, { r: 255, g: 182, b: 193 }],
  [{ r: 255, g: 69, b: 0 }, { r: 255, g: 140, b: 0 }],
  [{ r: 0, g: 128, b: 128 }, { r: 135, g: 206, b: 250 }],
  [{ r: 105, g: 105, b: 105 }, { r: 192, g: 192, b: 192 }]
];
const cloudColors = ['rgba(139, 69, 19,', 'rgba(154, 205, 50,', 'rgba(107, 142, 35,', 'rgba(160, 82, 45,', 'rgba(128, 128, 0,', 'rgba(85, 107, 47,'];

function spawnFartCloud() {
  const numClouds = Math.floor(Math.random() * 3) + 3;
  const palette = specklePalettes[Math.floor(Math.random() * specklePalettes.length)];
  const cloudColor = cloudColors[Math.floor(Math.random() * cloudColors.length)];
  
  for (let i = 0; i < numClouds; i++) {
    fartClouds.push({
      x: bird.x - 15, y: bird.y + 5,
      vx: -2 - Math.random() * 2, vy: 1 + Math.random() * 2,
      size: 8 + Math.random() * 8, opacity: 0.6,
      color: cloudColor, life: 0,
      specklePalette: palette,
      speckleDensity: 0.3 + Math.random() * 0.7,
      speckleSizeMin: 0.5 + Math.random() * 1.5,
      speckleSizeMax: 1.5 + 1 + Math.random() * 3
    });
  }
}

function updateFartClouds() {
  for (let i = fartClouds.length - 1; i >= 0; i--) {
    const cloud = fartClouds[i];
    cloud.x += cloud.vx;
    cloud.y += cloud.vy;
    cloud.life += 0.02;
    cloud.opacity = 0.6 - cloud.life;
    if (cloud.opacity <= 0) fartClouds.splice(i, 1);
  }
}

function drawFartClouds() {
  fartClouds.forEach(cloud => {
      ctx.fillStyle = cloud.color + cloud.opacity + ')';
      ctx.beginPath(); ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2); ctx.fill();

      const numSpeckles = Math.floor(cloud.size * cloud.speckleDensity);
      for (let i = 0; i < numSpeckles; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * cloud.size * 0.7;
        const speckleX = cloud.x + Math.cos(angle) * dist;
        const speckleY = cloud.y + Math.sin(angle) * dist;
        const speckleSize = cloud.speckleSizeMin + Math.random() * (cloud.speckleSizeMax - cloud.speckleSizeMin);
        const speckleOpacity = cloud.opacity * (0.5 + Math.random() * 0.5);
        const colorChoice = cloud.specklePalette[Math.floor(Math.random() * cloud.specklePalette.length)];
        ctx.fillStyle = `rgba(${colorChoice.r},${colorChoice.g},${colorChoice.b},${speckleOpacity})`;
        ctx.beginPath(); ctx.arc(speckleX, speckleY, speckleSize, 0, Math.PI * 2); ctx.fill();
      }
  });
}

// Environment Assets
const assets = {
  bg: {
      stars: null,
      initStars: function() {
        if (this.stars) return;
        this.stars = [];
        for (let i = 0; i < 100; i++) {
          this.stars.push({ x: Math.random() * 432, y: Math.random() * 500, size: Math.random() * 2 + 0.5, twinkle: Math.random() * Math.PI * 2 });
        }
      },
      draw: function() {
        this.initStars();
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#0a0a1a'); gradient.addColorStop(0.4, '#1a1a3a');
        gradient.addColorStop(0.7, '#2d1f3d'); gradient.addColorStop(1, '#1a1a2e');
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

        this.stars.forEach(star => {
          const twinkle = Math.sin(frames * 0.05 + star.twinkle) * 0.3 + 0.7;
          ctx.globalAlpha = twinkle; ctx.fillStyle = '#ffffff';
          ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        // Moon
        ctx.fillStyle = '#f5f5dc'; ctx.beginPath(); ctx.arc(canvas.width - 80, 100, 40, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#e0e0c0'; ctx.globalAlpha = 0.3;
        ctx.beginPath(); ctx.arc(canvas.width - 90, 90, 10, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(canvas.width - 70, 110, 8, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1.0;
        
        // City Silhouette
        ctx.
